---
title: "<span style = 'font-size: 100%;'> QTM 350: Data Science Computing </span>"
subtitle: "<span style = 'font-size: 100%;'> Topic 02: Computational Literacy, Command Line, and Version Control </span>"
author: "Professor: Davi Moreira"
date: "2024-01-23"
date-format: "MMMM DD, YYYY"
format:
  revealjs: 
    transition: slide
    background-transition: fade
    width: 1600
    height: 900
    center: true
    slide-number: true
    incremental: true
    chalkboard: 
      buttons: false
    preview-links: auto
    #logo: images/quarto.png
    footer: "Data Science Computing"
    theme: [simple, custom.scss]
---

## Topic Overview

::: columns
::: {.column width="34%"}
-   Computational Literacy

    -   Binary and Hexadecimal numbers
    -   Characters, ASCII, Unicode
    -   High vrs low level programming languages
    -   Compiled *vs* interpreted languages
:::

::: {.column width="33%"}
-   Command Line

    -   Shell basics
    -   Help!
    -   Navigating your system
    -   Managing your files
    -   Working with text files
    -   Redirects, pipes, and loops
    -   Scripting
:::

::: {.column width="33%"}
-   **Version Control**

    -   **Data Science Workflow**
    -   **Reproducibility**
    -   **Git and GitHub**
:::
:::

<br>

::: aside
::: fragment
*this lecture draws on materials from Simon Munzert [Intro to Data Science](https://github.com/intro-to-data-science-21/lectures/tree/main).*
:::
:::

# Project management

## Taming chaos

::: columns
::: {.column width="50%"}

In the data science workflow, there are two sorts of **surprises** and cognitive stress:

1. Analytical (often good)
2. Infrastructural (almost always bad)

:::{.fragment}

**Analytical surprise** is when you learn something from or about the data.

**Infrastructural surprise** is when you discover that:

:::

:::{.fragment}

- You can't find what you did before.
- The analysis code breaks.
- The report doesn't compile.
- The collaborator can't run your code.
:::

:::{.fragment}

Good project management lets you focus on the right kind of stress.

:::

:::

::: {.column width="50%" layout-valign="center"}

![](figs/pippi-langstrumpf.gif){width="700"}
:::
:::

## Keeping Future-you happy

- It’s often tempting to set up a project assuming that you will be the only person working on it, e.g. as homework.
- That’s almost never true.
- Coauthors and collaborators happen to the best of us.
- Even if not, there's someone else who you always have to keep happy: Future-you.
- Future-you is really the one you organize your projects for.
- Most importantly, they are who will enjoy the fruits of your data science labor, or have to fight back your chaos.
- So, be kind to Future-you. Establish a good workflow. You'll thank yourself later.

. . . 

<center>![](figs/michaeljfox-1.jpg){width="180"}![](figs/michaeljfox-2.jpg){width="200"}![](figs/michaeljfox-3.jpg){width="200"}</center>

## Project setup

You should **always** think in terms of projects.

A project is a **self-contained unit of data science work** that can be

- Shared
- Recreated by others
- Packaged
- Dumped

. . .

A project contains

- Content, e.g., raw data, processed data, scripts, functions, documents and other output

- Metadata, e.g., information about tools for running it (required libraries, compilers), version history

. . .

For R projects for example:

- Projects are folders/directories.
- Metadata is the [RStudio project](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) (`.Rproj`) files (perhaps augmented with the output of [renv](https://rstudio.github.io/renv/articles/renv.html) for dependency management) and `.git`.

## Setup: the folder structure

::: columns
::: {.column width="50%"}

**Structuring your working directory**

- One folder contains everything inside it.
- Directories keep things separate that should be separated.
- You decide on the fundamental structure. The project decides on the details.

:::{.fragment}

**Further thoughts**

- Ideally, your project folder can be relocated without problem.
- Keep input separate from output. Definitely separate raw from processed data!
- Structure should be capable of evolution. More data, cases, models, output formats shouldn't be a problem. 

:::
:::

::: {.column width="50%"}

<center>![](figs/rproject-setup.png){width="300"}</center>
<br>
<center>![](figs/r-project-setup-2.png){width="300"}</center>
<br>
<center>
[Chris/r-bloggers.com](https://www.r-bloggers.com/2018/08/structuring-r-projects/)
</center>

::: 
:::


## Setup: the paths

::: columns
::: {.column width="50%"}

**Good paths**

- All internal paths are relative.
- They are invariant to moving/sharing the project.
- Examples:
  - `"preprocessing.py"`
  - `"figures/model-1.png"`
  - `"../data/survey..csv"`
  

:::{.fragment}

**Bad paths**

- Absolute paths are bad paths. Don't feed functions with paths like `"/Users/me/data/thing.sav"`.
- Those paths will not work outside your computer (or maybe not even there, some days/weeks/months ahead).

:::
:::

::: {.column width="50%"}

:::{.fragment}

**The working directory**

- If you use `VS`, open the folder/directory where your project is.
- If you use `RStudio`, open it with clicking on the script you want to work with. This will set the location of the script as working directory (which should be your working assumption, too).
- Even better yet, have the metadata set it for you:
  - Open your session by opening (choosing, clicking on) `myproject.Rproj` 
  - Then you’ll get the path set for you. 

:::

::: 
:::


## Setup: the code structure

::: columns
::: {.column width="50%"}


**Naming scripts**

::: r-fit-text
- Files should have short, descriptive names that indicate their purpose.
- I recommend the use of telling verbs.
- Names should only include letters and numbers with dashes `-` or underscores `_` to separate words.
- Use numbering to indicate the order in which files should be run:
  - `00-setup.py`
  - `01-import-data.py`
  - `02-preprocess-data.py`
  - `03-describe-uptake.py`
  - `04-analyze-uptake.py`
  - `05-analyze-experiment.py`

:::  
:::

::: {.column width="50%"}

:::{.fragment}

**Modularizing scripts**

- Write short, modular scripts. Every script serves a purpose in your pipeline.
- This makes things easier to debug.
- At the beginning of a script you might want to document input and output.

:::

::: 
:::


## Setup: the code structure

::: columns
::: {.column width="50%"}


<!---::: r-fit-text--->

**Talk to Future-you**

- Describe your code, e.g. by starting with a description of what it does. If you comment/describe a lot, consider using an R Markdown (`.Rmd`) file instead of a simple `.R` script.
- Put the setup first (e.g., `library()` and `source()`).
- You might want to outsource the loading of packages to a separate script that is imported in the first step (`source("functions.R")`) or just declared the first script in the pipeline.
- Always comment more than you usually do.

<!---:::  --->
:::

::: {.column width="50%"}

:::{.fragment}

**Structuring your code**

- Even with modularized code, scripts can become long. Structure helps to keep an overview.
- Use commented lines as section/subsection heads. Many IDEs have features that help with it
- `RStudio`, for exemple, creates a "table of contents" when you name your code chunks as follows (`#` followed by title and `---`):

:::{.fragment}

```{r, eval = FALSE, echo = T}
# Import data --------------

dat <- read_csv("dat.csv")
```

:::

:::

::: 
:::


## Setup: the rest

::: columns
::: {.column width="50%"}

**More things to consider**

::: r-fit-text
- There'd be more to say on how to establish a good project workflow, including how to
  
    - store/organize raw and derived data,
    - deal with output in form of graphs and tables,
    - link everything together from start (project setup) to finish (knitting the report)
    - separate coding for the record and experimental coding.

- There's limited value in teaching you all that upfront.
- The truth is: You'll likely refine your own workflow over time. Hopefully, I just saved you some initial pain.

- Do check out other people's experiences and opinions, e.g., [here](https://www.r-bloggers.com/2018/08/structuring-r-projects/) or [here](https://chrisvoncsefalvay.com/2018/08/09/structuring-r-projects/) or [here](https://kdestasio.github.io/post/r_best_practices/).

::: 

:::

::: {.column width="50%"}


<center>![](figs/fuckingowl.png){width="600"}</center>

<center>**Managing your project in two simple steps**</center>

::: 
:::

# Version Control

## What is Version Control?

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->
- Version Control is a way to track your files 

- It is usually saved in a series of snapshots and branches, which you can move back and forth between

- Version Control allows you to view how project has progressed over time

- It allows you to:

    - Distribute your file changes over time
    - Prevent against data loss/damage by creating backup snapshots
    - Manage complex project structures (e.g. Linux)

<!---::: --->


:::

::: {.column width="50%"}

<center>![](figs/01-version-control.png){width="600"}</center>

::: 
:::

## Why version control?

<center>![](http://phdcomics.com/comics/archive/phd101212s.gif){width="550"}</center>

<center>[phdcomics.com](http://phdcomics.com/comics/archive.php?comicid=1531&quot;&gt;creativity&lt;/a&gt;.&lt;!--more--&gt;&lt;/p&gt;)</center>

## More reasons to do version control


::: columns
::: {.column width="50%"}

**Have you ever...**

::: r-fit-text
- Changed your code, realized it was a mistake and wanted to revert back?
- Lost code or had a backup that was too old?
- Wanted to see the difference between different versions of your code?
- Wanted to review the history of some code?
- Wanted to submit a change to someone else's code?
- Wanted to share your code, or let other people work on your code?
- Wanted to see how much work is being done, when, and by whom?
- Wanted to experiment with but not interfering with working code?

:::
:::{.fragment} 

<center> [si618/Stackoverflow](https://stackoverflow.com/questions/1408450/why-should-i-use-version-control)</center>

:::

:::

::: {.column width="50%"}

<center>![](figs/version-control-joke-2.jpeg){width="500"}</center>

<center>[bhimanshukalra/devrant.com](https://devrant.com/rants/1840468/version-control)</center>

::: 
:::

# Git and GitHub

## Git(Hub) solves this problem

::: columns
::: {.column width="50%"}

<br>

<center>![](figs/git-logo.png){width="300"}</center>

::: r-fit-text

- Git is a distributed version control system.
- Imagine if your Dropbox (or Google Drive, or MS OneDrive for that matter) and the "Track changes" feature in MS Word had a baby.
- In fact, it's even better than that because Git is optimized for the things that data scientists spend a lot of time working on - code!
- There is a learning curve, but it's worth it.
- Being familiar with Git is taken for granted when you interact with other data scientists.
- It is by far [not the only version control software](https://en.wikipedia.org/wiki/Comparison_of_version-control_software), but certainly the most popular one.
- According to [StackOverflow's 2021 Developer Survey](https://insights.stackoverflow.com/survey/2021#most-popular-technologies-tools-tech), more than 93% of respondents report to use Git - more than any other tool.

::: 

:::

::: {.column width="50%"}

:::{.fragment}

<br>

<center>![](figs/github-logo.png){width="400"}</center>

::: r-fit-text

- It's important to realize that Git and GitHub are distinct things.
- GitHub is an online hosting platform that allows you to host your code online.
- It relies on Git and makes some of its functionality more accessible.
- Also, it provides many more useful features to collaborate with others. (Similar platforms include Bitbucket and GitLab.)
- Just like we don't *need* Rstudio to run R code, we don't *need* GitHub to use Git... But it will make our lives easier.

::: 

:::

::: 
:::

## Git: some background

::: columns
::: {.column width="50%"}

::: r-fit-text

**Where does Git come from?**

- Git was created in 2005 by Linux creator Linus Torvalds.
- The initial motivation was to have a non-proprietary version control system to manage Linux kernel development.
- Check out this (quite opinionated) [talk by Linus Torvalds on Git](https://www.youtube.com/watch?v=4XpnKHJAok8) two years after its creation.


:::{.fragment}

**What's the meaning of `Git`?**

- Anything, [apparently](https://en.wikipedia.org/wiki/Git#Naming).
- Also, it's pronounced [ɡɪt], not [d͡ʒɪt].

:::

:::{.fragment}

**How to interact with Git?**

- There are many [Git GUIs](https://en.wikipedia.org/wiki/Comparison_of_Git_GUIs), giving you the option to use git without the shell (often with reduced functionality). Popular choices are the [GitHub Desktop](https://desktop.github.com/), and the [Git integration into the RStudio IDE](https://support.rstudio.com/hc/en-us/articles/200532077-Version-Control-with-Git-and-SVN).

:::

::: 

:::

::: {.column width="50%"}



<center>![[Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds)](figs/linus-torvalds.jpeg){width="300"}</center>
<br>
<center>![](figs/git-logo-2.png){width="300"}</center>
<br>

<!---<center>[Krd (photo), Von Sprat (crop/extraction), CC BY-SA 4.0.](https://commons.wikimedia.org/w/index.php?curid=54706023)</center>--->

::: 
:::

## GitHub: some background

::: columns
::: {.column width="50%"}
::: r-fit-text
::: {.fragment}

**Where does GitHub come from?**

- GitHub.com launched in April 2008 by [Tom Preston-Werner, Chris Wanstrath, P.J. Hyett and Scott Chacon](https://productmint.com/github-business-model-how-does-github-make-money/).

- In 2018, Microsoft acquired the company for more than US$7 billion.

:::

::: {.fragment}

**What's the business model?**

- GitHub offers various subscription plans and has expanded its services beyond hosting Git-based version control.

:::

::: {.fragment}

**Some interesting facts**

- GitHub's mascot is "[Octocat](https://github.com/octocat)", a human-cat-octopus hybrid with five arms. 

- There are [56m+ developers on Github](https://octoverse.github.com/), with 60m+ new repositories created in 2020 alone.

- Part of GitHub's history are controversies around issues like harassment allegations or incidences of censorship.

:::

:::
:::

::: {.column width="50%"}

<center>![](figs/octocat.png){width="400"}</center>

<center>[Screenshot](https://github.com/octocat3)</center>

:::
:::


## Git(Hub) for scientific research

::: columns
::: {.column width="50%"}
::: r-fit-text

**From software development...**

- Git and GitHub's role in global software development is not in question.
- There's a high probability that your favourite app, program or package is built using Git-based tools. (RStudio is a case in point.)

::: {.fragment}

**... to scientific research**

- Data science involves product building, collaboration, transparency. GH helps with all that.
- Journals have increasingly strict requirements regarding reproducibility and access. GH makes this easy (DOI integration, off-the-shelf licenses, etc.).
- My [website](https://davi-moreira.github.io/) lives there. And this [course](https://github.com/davi-moreira/2024S_dsc_emory_qtm_350) does, too.

:::
:::
:::

::: {.column width="50%"}

<center>![](figs/github-van-nooren.webp){width="500"}</center>


<center>"[Democratic databases: science on GitHub](https://www.nature.com/news/democratic-databases-science-on-github-1.20719)" (Perkel, 2016, *Nature*).</center>

:::
:::

# Getting started with Git and GitHub

## First step: register a GitHub account

::: columns
::: {.column width="50%"}
<!---::: r-fit-text--->

Good news: It's free!

Simply go to [https://github.com](https://github.com) to sign up.

:::{.fragment}

Some things to consider:

- As a student, you qualify for a [free GitHub Pro account](https://education.github.com/discount_requests/student_application).
- The Pro account comes with a couple of [additional features](https://docs.github.com/en/get-started/learning-about-github/githubs-products#github-pro).
- Register for a free account first, then pursue the special offers.
- Choose your username [wisely](https://happygitwithr.com/github-acct.html). This isn't Instagram, so maybe avoid puns and "funny" nicknames.

<!---:::--->

::: 

:::

::: {.column width="50%"}

<center>![](figs/brent-rambo.gif){width="600"}</center>

:::
:::

## Second step: install Git

Again, Git is an independent piece of software. You need to have it installed on your machine to call it from the `Command Line` or `RStudio`.

. . .

Chances are that that's already the case. Here's how you can check using the command line:

```{bash, echo = T}
which git
```

. . .

And here's how you can check the version:

```{bash, echo = T}
git --version
```

. . .

If you want to install (or update) Git on your Mac/Linux machine, I recommend using [Homebrew](https://brew.sh/), "the missing package manager for macOS (or Linux)":

```{bash, eval = FALSE, echo = T}
brew install git
```

. . .

To install/update Git for Windows, check out [happygitwithr.com](https://happygitwithr.com/install-git.html).


## Third step: introduce yourself to Git

This is particularly important when you work with Git but without the GitHub overhead. The idea is to define how your commits are labelled. Others should easily identify your commits as coming from you.

. . . 

Have you already introduced yourself to Git? Find it out:

```{bash, eval = FALSE, echo = T}
git config --list
```

. . . 

Still have to introduce yourself? To that end, we set our user name and email address like this:

```{bash, eval = FALSE, echo = T}
git config --global user.name 'davimoreira'
git config --global user.email 'davi.moreira@example.com'
```

. . . 

The user name can be (but does not have to be) your GitHub user name. The email address should definitely be the one associated with your GitHub account.

. . . 

Check out [these setup instructions](https://swcarpentry.github.io/git-novice/02-setup.html) from [Software Carpentry](https://software-carpentry.org/about/) to learn about more configuration options.

# Git from the shell

## Why bother with the shell?


::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->

**Some benefits of the shell**:

- The shell is powerful and flexible. It lets you do things that the RStudio Git GUI can't (we will see it later).

- Working in the shell is potentially more appropriate for projects that aren't primarily based in `R`.

- Knowing the basic Git commands in the shell is a good thing for a data scientist.

<!---:::---> 
:::

::: {.column width="50%"}

<center>![](figs/shell-spongebob.webp){width="500"}</center>

::: 
:::


## The Git Workflow

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->

- Git goes through a long chain of operations and tasks before tracking a change.

- Many of these tasks are user controlled, and are required for changes to be tracked correctly.


<!---:::--->
:::
::: {.column width="50%"}

<center>![](figs/02-version-control.png){width="350"}</center>

<center>[Git Cheatsheet](https://github.com/joshnh/Git-Commands)</center>

::: 
:::


## Repositories

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->

- Repositories, usually called ‘repos’, store the full history and source control of a project.

- They can either be hosted locally, or on a shared server, such as `GitHub`.

- Most repositories are stored on `GitHub`, while core contributors make copies of the repository on their machine and update the repository using the `push/pull` system.

- Any repository stored somewhere other than locally is called a ‘remote repository’.


<!---:::---> 
:::

::: {.column width="50%"}

<center>![](figs/03-version-control.png){width="400"}</center>

::: 
:::

## Repos vs Directories

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->

- Repositories are timelines of the entire project, including all 

- Directories, or ‘working directories’ are projects at their current state in time.

- Any local directory interacting with a repository is technically a repository itself, however, it is better to call these directories ‘local repositories’, as they are instances of a remote repository.

<!---::: --->


:::

::: {.column width="50%"}

<center>![](figs/04-version-control.png){width="600"}</center>

::: 
:::

## Workflow Diagram

::: columns
::: {.column width="50%"}

<br>

<!---::: r-fit-text--->

- This diagram shows a little bit about how the basic Git workflow process works

- The staging area is the bundle of all the modifications to the project that are going to be committed.

- A ‘commit’ is similar to taking a snapshot of the current state of the project, then storing it on a timeline.

<!---::: --->


:::

::: {.column width="50%"}

<center>![](figs/05-version-control.jpg){width="400"}</center>

::: 
:::



## Hands on! Creating a New Repository

::: columns
::: {.column width="50%"}

::: r-fit-text

1. I will create a new folder/directory in my computer: `my_project` 

2. Open the `bash` Terminal and move to the `my_project` directory

3. I will copy the `my_project` directory path into a text document 

4. I will try to add this folder to the `staging area`.

:::{.fragment}

```{bash, echo = T, eval = F}
git add .
```

:::

5. Error!

6. We need to initialize the repository. **Do not do that in your root directory!**

:::{.fragment}

```{bash, echo = T, eval = F}
git init
```

:::

::: 


:::

::: {.column width="50%"}

<center>![](figs/06-version-control.png){width="600"}</center>

::: 
:::

## Hands on! Adding/Removing files from the `repo`

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Open the `bash` Terminal and move to the `my_project` directory

2. To check the `staging area` status.

:::{.fragment}

```{bash, echo = T, eval = F}
git status
```

:::

3. Let's add the `path` file to the `staging area`. Then, check its status.

:::{.fragment}

```{bash, echo = T, eval = F}
git add path.txt
git status
```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/08-version-control.png){width="600"}</center>

::: 
:::


## Hands on! Adding/Removing files from the `repo`

::: columns
::: {.column width="50%"}

::: r-fit-text

4. Let's create new files in the project and check `staging area` status:

:::{.fragment}

```{bash, echo = T, eval = F}
touch file.txt
touch script.py
touch report.html
touch style.css
git status
```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/09-version-control.png){width="600"}</center>

::: 
:::


## Hands on! Adding/Removing files from the `repo`

::: columns
::: {.column width="50%"}

::: r-fit-text

5. Instead of adding each file to the `staging area` at once. We can do add all them together:

:::{.fragment}


```{bash, echo = T, eval = F}
git add .
git status
```

:::

::: 


:::

::: {.column width="50%"}

<center>![](figs/10-version-control.png){width="600"}</center>

::: 
:::

## Hands on! Adding/Removing files from the `repo`

::: columns
::: {.column width="50%"}

::: r-fit-text

6. In the directory, let's delete the `.py` and the `.css` files. Check the status:

:::{.fragment}

```{bash, echo = T, eval = F}
rm -f script.py
rm -f style.css
git status
```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/11-version-control.png){width="600"}</center>

::: 
:::



## Hands on! First Commit

::: columns
::: {.column width="50%"}

::: r-fit-text

1. (cont.) In the directory, let's do our "initial commit" :

:::{.fragment}

```{bash, echo = T, eval = F}
git commit -m "initial commit"
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/12-version-control.png){width="600"}</center>

::: 
:::

## Hands on! First Commit

::: columns
::: {.column width="50%"}

::: r-fit-text

2. To check all commits in your `repo`:

:::{.fragment}

```{bash, echo = T, eval = F}
git log
```

:::

- Most important things here are:   

    - commit id;
    - date/time;
    - branch;
    - commit message;
    
::: 
:::

::: {.column width="50%"}

<center>![](figs/13-version-control.png){width="600"}</center>

::: 
:::

<!---

## Hands on! Git Checkout

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Let's make new commits in our `repo`:

:::{.fragment}

```{bash, echo = T, eval = F}
touch script.py  # new file
touch webpage.html. # new file
touch style.css  # new file
git add . # add files to the staging area
git commit -m "adding files" # new commit
echo "Hello you" >> file.txt   # edit .txt file
git add . # add files to the staging area
git commit -m "edditing file.txt". # new commit
git log  # lets check
```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/14-version-control.png){width="600"}</center>

::: 
:::

--->

## Hands on! Git Checkout

::: columns
::: {.column width="50%"}

::: r-fit-text

1. First, let's make new commits in our `repo`:

:::{.fragment}

```{bash, echo = T, eval = F}
touch script.py  # new file
touch webpage.html. # new file
touch style.css  # new file
git add . # add files to the staging area
git commit -m "adding files" # new commit
echo "Hello you" >> file.txt   # edit .txt file
git add . # add files to the staging area
git commit -m "edditing file.txt". # new commit
rm -f file.txt. # remove file
git commit -a -m "delete file.txt" # new commit
git log  # lets check
```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/14-version-control.png){width="700"}</center>

::: 
:::

## Hands on! Git Checkout

::: columns
::: {.column width="50%"}

::: r-fit-text

2. We use `checkout` to go back in time to a given commit. Let's go back to the "initial commit":

:::{.fragment}

```{bash, echo = T, eval = F}
git checkout 2b543ff2b3423a6d01727a11603792783315680d
git log
```

:::

- Check your `folder/directory`!

- **Important**: doing this does not delete our commits. We just move back in time!

::: 

:::

::: {.column width="50%"}

<center>![](figs/15-version-control.png){width="700"}</center>

::: 
:::

## Hands on! Git Checkout

::: columns
::: {.column width="50%"}

::: r-fit-text

3. To "move back to the future", the most recent commit, we just need to go back to the main branch:

:::{.fragment}

```{bash, echo = T, eval = F}
git checkout main
git log
```

:::

- Check your `folder/directory`!

- **Important**: doing this does not delete our commits. We just move back and forth in time!

::: 

:::

::: {.column width="50%"}

<center>![](figs/16-version-control.png){width="700"}</center>

::: 
:::


## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Let's create a new text file, `notes.txt`,  and make some edits. 

:::{.fragment}

```{bash, echo = T, eval = F}
touch notes.txt   
echo "Welcome to Data Science Computing" >> notes.txt
git status
git add .
git status
echo "I hope you enjoy" >> notes.txt
git status                          
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/17-version-control.png){width="700"}</center>

::: 
:::

## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

2. Let's say we do not want to track this file (can be a folder or many files).

3. To do so, we tell Git to ignore those files or folders. We create a `.gitignore` file.

:::{.fragment}

```{bash, echo = T, eval = F}
touch .gitignore
```

:::

4. In the `.gitignore` we list everything we want Git to ignore.

::: 
:::

::: {.column width="50%"}

<center>![](figs/18-version-control.png){width="700"}</center>

::: 
:::

## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

5. Let's add them to the `staging area` and do a new commit.

:::{.fragment}

```{bash, echo = T, eval = F}
git status
git add .
git status
git commit -m "added gitignore"
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/19-version-control.png){width="700"}</center>

::: 
:::

<!---
## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

2. Let's say we do not want to track this file (can be a folder or many files).

3. To do so, we tell Git to ignore those files or folders. We create a `.gitignore` file.

:::{.fragment}

```{bash, echo = T, eval = F}
touch .gitignore
```

:::

4. In the `.gitignore` we list everything we want Git to ignore.

::: 
:::

::: {.column width="50%"}

<center>![](figs/18-version-control.png){width="700"}</center>

::: 
:::

## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

5. Let's add them to the `staging area` and do a new commit.

:::{.fragment}

```{bash, echo = T, eval = F}
git status
git add .
git status
git commit -m "added gitignore"
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/19-version-control.png){width="700"}</center>

::: 
:::
--->

## Hands on! `.gitignore`

::: columns
::: {.column width="50%"}

::: r-fit-text

6. Now, let's edit the `notes.txt` file.
7. Check `git status`
8. We need to update the cached files list, commit these updates and... 
7. Let's edit the `notes.txt` file one more time.
8. Finally, let's check if the `notes.txt` file is being tracked.

:::{.fragment}

```{bash, echo = T, eval = F}
echo "New line in the file" >> notes.txt
git status
git rm -r --cached .
git add .
git commit -m "fixed file tracking"
echo "The previous edition was not the last one" >> notes.txt
git status
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/20-version-control.png){width="600"}</center>

::: 
:::

# Git branches

## Git branches

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->

<br>

1. Git branches are a way to create separate development paths without overriding or creating copies of your project.

2. Branches can be added, deleted, and merged, just like regular commits.

<!---::: --->


:::

::: {.column width="50%"}


<center>![](figs/01-branching.gif){width="700"}</center>
<center>[Technical Foundations of Informatics](https://info201.github.io/git-branches.html)</center>

::: 
:::

## Git branches

::: columns
::: {.column width="50%"}

<!---::: r-fit-text--->


Branches can be used to:

- Create separate development paths without overriding progress
- Separate different end goals of your project
- Creates separate branches for each stage of development (release, development, fixes, master)
- Creates separate branches for project collaboration!

<!---::: --->

:::

::: {.column width="50%"}

<center>![](figs/02-branching.png){width="300"}</center>

::: 
:::



## Git branches: Hands on!

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Let's create a `new_project` directory.

:::{.fragment}

```{bash, echo = T, eval = F}
mkdir new_project
git init
mkdir src
mkdir lib
cd src/
touch file.txt
touch script.js
cd ..
cd lib/
touch lib.py
touch file2.txt
cd ..
git status
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/04-branching.png){width="550"}</center>

<center>![](figs/03-branching.jpg){width="550"}</center>

::: 
:::

## Git branches: Hands on!

::: columns
::: {.column width="50%"}

::: r-fit-text


2. Let's do our initial commit, create a new branch `dev`, and  switch to the new branch.
3. Then, let's go back to the `main` branch, create a new one `bugs`, and list them

:::{.fragment}


```{bash, echo = T, eval = F}
git add .
git commit -m "initial commit"
git checkout -b dev 
git add .
git commit -m "initial commit"
git checkout main
git branch bugs
git branch -a
git branch -d bugs # to delete
```

:::

::: 
:::

::: {.column width="50%"}

<center>![](figs/05-branching.png){width="550"}</center>

<center>![](figs/03-branching.jpg){width="550"}</center>

::: 
:::

## Git branches: Hands on!

::: columns
::: {.column width="50%"}

::: r-fit-text


4. Let's work on our `dev` branch.
5. Add a `version.txt` file 
6. Then, let's merge our branches.
7. To move on in our workflow, we can move back to the `dev` branch and do a new commit and keep working in the `dev` branch.

:::{.fragment}

```{bash, echo = T, eval = F}
git checkout dev
echo "new text" >> file.txt
git add .
git commit -m "new file.txt content"
echo "new text" >> myfile.txt
git add .
git commit -m "new myfile.txt content"
git log
touch version.txt
echo "1.0" >> version.txt
git status
git add .
git commit -m "release v1.0"
git checkout main
git merge dev
git log
git checkout dev
git add .
git commit -m "starting new version"
git log

```

:::

Check this material for more on [Merge & Branches](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging).

::: 
:::

::: {.column width="50%"}

<center>![](figs/06-branching.png){width="550"}</center>

<center>![](figs/03-branching.jpg){width="550"}</center>

::: 
:::

# Git and GitHub

## GitHub: Creating a New Repository


1. First, we create a new repo on GitHub

:::{.fragment}

<center>![](figs/01-github.png){width="1300"}</center>

:::


## GitHub: Creating a New Repository


2. We copy the remote `repo` address.

:::{.fragment}

<center>![](figs/02-github.png){width="1300"}</center>

:::


## GitHub: Creating a New Repository

::: columns
::: {.column width="50%"}

::: r-fit-text

3. We connect our local `Git` repo with the remote `GitHub` repo
:::
:::{.fragment}

```{bash, echo = T, eval = F}
cd Desktop/qtm_350_24S_02
git init
git remote add origin https://github.com/davi-moreira/qtm_350_24S_02.git
git remote -v
```


::: 
:::

::: {.column width="50%"}

<center>![](figs/06-github.png){width="700"}</center>

::: 
:::



## The Push and Pull System

::: columns
::: {.column width="50%"}

::: r-fit-text


- The Git/GitHub push and pull system is central to collaborating on coding projects. It allows multiple developers to work on the same project without conflicts.


- **The Push Operation**: Sends your local commits to the remote repository.
    
    - `git push origin main` - pushes commits from your local `main` branch to the remote `main` branch.

- **The Pull Operation**: Fetches the latest changes from the remote repository and merges them into your local repository.

    - `git pull origin main` - pulls changes from the remote `main` branch and merges them into your local `main` branch.

- **Best Practices**:

    - Pull often to keep your local repository up-to-date.
    - Push regularly to share your contributions with the team.

::: 

:::

::: {.column width="50%"}

<center>![](figs/01-push-pull.png){width="600"}</center>

::: 
:::



## The Push and Pull System


1. Starting with the Pull request
2. Let's create a `README.md` file in the remote `repo` and `commit`: 

:::{.fragment}

<center>![](figs/03-github.png){width="1500"}</center>

:::


## The Push and Pull System

2. Let's create a `README.md` file in the remote `repo` and `commit`: 

:::{.fragment}

<center>![](figs/04-github.png){width="700"}</center>

:::

## The Push and Pull System

3. Let's create a `LICENSE` and `.gitignore` files in the remote `repo` and `commit`: 

:::{.fragment}

<center>![](figs/05-github.png){width="1300"}</center>

:::


## The Push and Pull System

::: columns
::: {.column width="50%"}

::: r-fit-text


3. Now we can make a `Pull` request

:::{.fragment}

```{bash, echo = T, eval = F}
git pull origin main
git status
git log

```

:::

::: 

:::

::: {.column width="50%"}

<center>![](figs/07-github.png){width="700"}</center>

::: 
:::

## The Push and Pull System

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Now let's see the Push request.
2. Let's delete the `LICENSE.md` file locally and commit.
3. Now we can make a `Push` request. Conditioned on your settings, it will requires your user name and password.
4. Let's check the remote `repo` on GitHub.

:::{.fragment}

```{bash, echo = T, eval = F}
rm -rf LICENSE
ls
git status
git add .
git commit -m "remove LICENSE file"
git log
git push -u origin main

```

:::
::: 


:::

::: {.column width="50%"}

<center>![](figs/08-github.png){width="480"}</center>
<center>![](figs/09-github.png){width="480"}</center>

::: 
:::

## The Push and Pull System

::: columns
::: {.column width="50%"}

::: r-fit-text

1. Now let's create a branch to correct the mistake in the `README.md` file.

:::

:::{.fragment}

```{bash, echo = T, eval = F}
git pull
git checkout -b err01
# open the file and edit
git status
git add .
git commit -m "fixed mistake in readme file"
git checkout main
git merge err01
git log
git push
# let's check the remote repo
git push origin err01
# let's check the remote repo and check the commits
# git push origin --delete err01 # to delete the branch in the remote repo
```

::: 

:::

::: {.column width="50%"}

<center>![](figs/10-github.png){width="700"}</center>

::: 
:::

## The Push and Pull System

Can anybody push to my repository?

>No, all repositories are read-only for anonymous users. By default only the owner of the repository has write access. If you can push to your own repo, it’s because you are using one of the supported authentification methods (HTTPS, SSH, …).

>If you want to grant someone else privileges to push to your repo, you would need to configure that access in the project settings.

>To contribute to projects in which you don’t have push access, you push to your own copy of the repo, then ask for a pull-request.

[source: https://stackoverflow.com/questions/17442930/can-anybody-push-to-my-project-on-github](https://stackoverflow.com/questions/17442930/can-anybody-push-to-my-project-on-github)

# RStudio + GitHub + Git

## RStudio + GitHub + Git

<br>

<center>![](figs/01-github-r.png){width="1000"}</center>

<center>[Happy Git and GitHub for the useR](https://happygitwithr.com/), [Heaven King video](https://www.youtube.com/watch?v=uBWrpVrazzA)</center>

## RStudio + GitHub + Git

1. Create a remote `repo`
2. Create an RStudio Project and connect with the remote `repo`
3. Commit locally
4. Push and Pull
5. Create a new branch
6. Merge
7. Push and Pull
8. **Have Fun!**

# Collaboration with Git and GitHub

## Collaborating Workflows

::: columns
::: {.column width="50%"}

::: r-fit-text


- There is no one size fits all Git workflow. 
- It is important to develop a Git workflow that is a productivity enhancement for the team. 
- A workflow should also complement business culture. 

::: 

:::

::: {.column width="50%"}

<center>![](figs/01-collaboration.png){width="700"}</center>

::: 
:::



## Centralized Workflow

::: columns
::: {.column width="50%"}

::: r-fit-text


- Uses a central repository to serve as the single point-of-entry for all changes to the project. The default development branch it the `main` branch and all changes are committed into this branch. This workflow doesn’t require any other branches besides main.

- Also check: 

    -[Inviting collaborators to a personal repository](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository)

::: 

:::

::: {.column width="50%"}

<center>![](figs/02-collaboration.svg){width="700"}</center>
<center>[Centralized workflow](https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow)</center>

::: 
:::



## Feature Branch Workflow


::: columns
::: {.column width="50%"}

::: r-fit-text

- All feature development should take place in a dedicated branch instead of the `main` branch. This encapsulation makes it easy for multiple developers to work on a particular feature without disturbing the main codebase. It also means the main branch will never contain broken code, which is a huge advantage for continuous integration environments.

- Also check: 

    - [Inviting collaborators to a personal repository](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-access-to-your-personal-repositories/inviting-collaborators-to-a-personal-repository) 
    - [Resolving a merge conflict using the command line](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line)
    - [A Successful Git Branching Model](https://nvie.com/posts/a-successful-git-branching-model/)
    -[Learn Git Branching](https://learngitbranching.js.org/)

::: 


:::

::: {.column width="50%"}

<center>![](figs/01-collaboration.png){width="700"}</center>
<center>[Feature Branch Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows)</center>

::: 
:::




## Forking Workflow

::: columns
::: {.column width="50%"}

::: r-fit-text

- Instead of using a single server-side repository to act as the “central” codebase, it gives every developer a server-side repository. This means that each contributor has not one, but two Git repositories: a private local one and a public server-side one. 
- Also check: 

    - [Collaborating with pull requests](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests)
    - [Merging a pull request](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request)
    - [Checking out pull requests locally](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/reviewing-changes-in-pull-requests/checking-out-pull-requests-locally)

:::
:::

::: {.column width="50%"}

<center>![](figs/03-collaboration.svg){width="700"}</center>
<center>[Forking Workflow](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow)</center>

::: 
:::

# Summary

## Summary

- Project Management is a central practice in Data Science Projects

- Keep Future-you Happy!

- The Folder Structure must be respected.

- Guidelines for naming scripts, modularizing code, and structuring your code effectively for future readability and usability.

- Version Control helps to track changes in files and coordinate work among multiple people.

- Git and GitHub are the current main tools for Version Control and Data Science project collaboration

- There is no unique Collaborating Workflow, but one of them can fit your team!


# Thank you!
